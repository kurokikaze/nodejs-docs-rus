## HTTP

Для использования клиента и сервера HTTP необходимо подключить
соответствующий модуль с помощью `require('http')`.

Интерфейс HTTP спроектирован в Node таким образом, чтобы поддерживать многие
возможности протокола, которые традиционно было довольно сложно использовать.
В частности, большие сообщения с возможным chunk-encoding. Интерфейс никогда
не сохраняет в буфере целиком запрос или ответ, давая пользователю возможность
принимать и отправлять данные в потоковом режиме.

Заголовки сообщения HTTP представлены примерно таким объектом:

    { 'content-length': '123',
      'content-type': 'text/plain',
      'connection': 'keep-alive',
      'accept': '*/*' }

Ключи приводятся к нижнему регистру. Значения не изменяются.

Для поддержки всего спектра возможных применений HTTP, соответствующее API
в Node довольно низкоуровневое. Оно основано на потоках и передаче сообщений.
Node разбирает HTTP-сообщение на заголовки и тело, остальное должен сделать
программист.

HTTPS поддерживается если на целевой платформе доступен OpenSSL.

## http.Server

Это `EventEmitter` со следующими событиями:

### Событие: 'request'

`function (request, response) { }`

Генерируется каждый раз при получении запроса. Заметьте, что в течении одного
соединения может происходить несколько запросов (в случае keep-alive соединения).
Объект `request` — экземпляр `http.ServerRequest`,
объект `response` — экземпляр `http.ServerResponse`.

### Событие: 'connection'

`function (stream) { }`

Генерируется при установке нового HTTP-соединения. `stream` — объект типа `net.Stream`.
Обычно пользователи не используют это событие. Объект потока `stream` также можно
найти в свойстве объекта запроса `request.connection`.

### Событие: 'close'

`function (errno) { }`

Генерируется при завершении работы сервера.

### Событие: 'checkContinue'

`function (request, response) {}`

Событие наступает кажды раз при получении заголовка `'Expect: 100'`.
Если для этого события не назначен ни один обработчик, то сервер автоматически
отвечает `'100 Continue'`.

Обработка этого события подразумевает вызов `response.writeContinue` если клиент
должен продолжить отправку тела запроса, или генерацию другого HTTP запроса
(например `'400 Bad Request'`) если клиент не должен этого делать.

Имейте в виду, что если это событие наступило и было обработано, то событие
`request` не наступает.

### Событие: 'upgrade'

`function (request, socket, head)`

Генерируется каждый раз когда клиент запрашивает апгрейд соединения
до защищённого (см. RFC 2817). Если это событие никак не обрабатывается
соединение для которого запрошен апгрейд будет закрыто.

* `request` — аргументы для HTTP запроса, как в событии `'request'`.
* `socket` — сетевой сокет между сервером и клиентом.
* `head` — экземпляр Buffer, первый пакет защищенного потока, может быть пустым.

После генерации этого события, у объекта `server` не будет обработчика события
`data`, и программисту нужно назначить его заново чтобы обрабатывать данные,
получаемые этим соединением.

### Событие: 'clientError'

`function (exception) {}`

Если соединение с клиентом генерирует событие `'error'` — оно поднимается сюда.

### http.createServer(requestListener)

Возвращает новый объект web-сервера.

Функция `requestListener` автоматически добавляется к событию `'request'` сервера.

### server.listen(port, [hostname], [callback])

Начинает приём соединений на указанном порту и имени хоста. Если имя хоста не указано,
сервер будет принимать соединения на любой IPv4-адрес машины (`INADDR_ANY`).

Чтобы слушать unix-сокет, передайте имя файла вместо порта и имени хоста.

Эта функция асинхронна. Функция, переданная последним параметром `callback`
будет вызвана когда сервер будет связан с портом.


### server.listen(path, [callback])

Начинает слушать unix-сокет с заданным путём `path`.

Эта функция асинхронна. Функция, переданная последним параметром `callback`
будет вызвана когда сервер будет связан с сокетом.


### server.close()

Прекращает приём новых соединений сервером.


## http.ServerRequest

Этот объект создаётся автоматически HTTP-сервером (не пользователем)
и передаётся первым аргументом обработчику события `'request'`.

Это `EventEmitter` со следующими событиями:

### Событие: 'data'

`function (chunk) { }`

Генерируется при получении части тела сообщения.

Пример: Часть тела сообщения передаётся как единственный аргумент. Сообщение
уже раскодировано из transfer-encoding. Часть тела представлена в виде строки.
Кодировка тела сообщения задаётся `request.setBodyEncoding()`.

### Событие: 'end'

`function () { }`

Генерируется строго один раз для каждого сообщения. Нет аргументов. После этого
события запрос не будет генерировать другие.


### request.method

Метод запроса в виде строки. Только для чтения. Пример `'GET'` или `'DELETE'`.


### request.url

Строка с URL запроса. Здесь содержится URL в том виде, в котором он задан
в самом HTTP-запросе. Если запрос выглядит так:

    GET /status?name=ryan HTTP/1.1\r\n
    Accept: text/plain\r\n
    \r\n

Тогда значением `request.url` будет:

    '/status?name=ryan'

Если вы хотите разделить URL на составные части, вы можете использовать
`require('url').parse(request.url)`. Пример:

    node> require('url').parse('/status?name=ryan')
    { href: '/status?name=ryan',
      search: '?name=ryan',
      query: 'name=ryan',
      pathname: '/status' }

Если вам нужно извлечь параметры из строки запроса, можно использовать функцию
`require('querystring').parse`, или передать `true` в качестве второго аргумента
`require('url').parse`. Пример:

    node> require('url').parse('/status?name=ryan', true)
    { href: '/status?name=ryan',
      search: '?name=ryan',
      query: { name: 'ryan' },
      pathname: '/status' }


### request.headers

Заголовки запроса. Только для чтения.

### request.trailers

HTTP trailers (если есть). Только для чтения.
Доступны тольк после наступления события `'end'`.

### request.httpVersion

Версия протокола HTTP в виде строки. Только чтение. Пример: `'1.1'`, `'1.0'`.
Также `request.httpVersionMajor` содержит первое число и `request.httpVersionMinor` — второе.


### request.setEncoding(encoding=null)

Задаёт кодировку тела запроса. Либо `'utf8'`, либо `'binary'`. По умолчанию
принимает значение `null`, что означает что в обработчик события `'data'`
поступает буфер.


### request.pause()

Прекращает генерирование событий запросом.
Можно использовать для ускорения закачки файла.


### request.resume()

Возобновляет генерирование событий запросом

### request.connection

Объект соединения, экземпляр `net.Stream`.

При поддержке HTTPS достоверность и содержимое сертификата могут быть проверены
с помощью методов `verifyPeer()` и `getPeerCertificate()`
объекта `request.connection` сервера.



## http.ServerResponse

Этот объект создаётся внутри HTTP-сервера — не пользователем. Он передаётся
вторым параметром в обработчик события `'request'` и является `потоком с возможностью записи`.

### response.writeContinue()

Отправдяет клиенту сообщение `'HTTP/1.1 100 Continue'`, которое разрешает
отправку тела запроса. См. описанеи события `checkContinue` объекта `http.Server`.

### response.writeHead(statusCode, [reasonPhrase], [headers])

Отправляет заголовки ответа клиенту. `statusCode` это три цифры кода статуса HTTP,
например 404. Последний аргумент, `headers`, это заголовки ответа. Также вторым
аргументом можно передать фразу `reasonPhrase`.

Пример:

    var body = 'hello world';
    response.writeHead(200, {
      'Content-Length': body.length,
      'Content-Type': 'text/plain' });

Этот метод должен быть вызван только однажды для каждого сообщения
и должен быть вызван до `response.end()`.

### response.write(chunk, encoding='utf8')

Этот метод должен вызываться после `writeHead`. Он отправляет часть тела ответа.
Метод может быть вызван несколько раз для отправки последующих частей тела ответа.

Аргумент `chunk` может быть буфером или строкой. Если `chunk` это строка, то
бойвторой параметр указывает в какой кодировке отправлять её в поток.
По умолчанию encoding принимает значение 'utf8'.

**Замечание:** Это необработанное тело HTTP-ответа и не имеет отношения к более
высокоуровневым вещам вроде multi-part encoding, которые тоже могут использоваться.

После первого вызова `response.write()` клиенту будет отправлены заголовки
и первая часть тела сообщения. После второго вызова `response.write()` Node
предполагает что вы начинаете потоковую передачу данных и отправляет часть
тела отдельно. Таким образом, данные буферизуются только до первой части тела ответа.

### response.addTrailers(headers)

Этот метод добавляет завершающие заголовки HTTP, следующие после тела ответа.

Эти заголовки могут быть использованы **только* в случае использование ответом 
`chunked encoding`; в противном случае они будут проигнорированы.

Имейте в виду, что протокол HTTP требует указания заголовка `Trailer`
в случае использования HTTP trailers, например:

    response.writeHead(200, { 'Content-Type': 'text/plain',
                              'Trailer': 'TraceInfo' });
    response.write(fileData);
    response.addTrailers({'Content-MD5': "7895bf4b8828b55ceaf47747b4bca667"});
    response.end();


### response.end([data], [encoding])

Этот метод отправляет серверу сигнал что все заголовки и тело ответа отправлены;
сервер должен считать это сообщение законченным. Метод `response.end()`
**ДОЛЖЕН** быть вызван при каждом ответе.

Если задан аргумент `data`, то этот вызов эквивалентен поледовательному вызову
`response.write(data, encoding)` и `response.end()`.


## http.Client

HTTP-клиент создаётся принимая адрес сервера в качестве аргумента, возвращаемый
идентификатор используется для отправки одного или нескольких запросов.
В зависимости от того, к какому серверу совершено подключение клиент может
использовать pipeline (несколько запросов за соединение) либо пересоздавать
поток после каждого запроса. _Текущая версия не использует pipeline_.

Пример подключения к `google.com`:

    var http = require('http');
    var google = http.createClient(80, 'www.google.com');
    var request = google.request('GET', '/',
      {'host': 'www.google.com'});
    request.end();
    request.on('response', function (response) {
      console.log('STATUS: ' + response.statusCode);
      console.log('HEADERS: ' + JSON.stringify(response.headers));
      response.setEncoding('utf8');
      response.on('data', function (chunk) {
        console.log('BODY: ' + chunk);
      });
    });

Нужно иметь в виду следующие особенности реализации:

* Заголовок 'Host' не добавляется Node, но обычно требуется для работы с сайтами.

* Отправка заголовка 'Connection: keep-alive' сообщает Node о необходимости
  сохранять соединения для последующих запросов.

* Отправка заголовка `'Content-length'` отключит 'chunked encoding'.

* Отправка заголовка 'Expect' немедленно приведёт к отправке всех заголовков.
  Обычно, при отправке 'Expect: 100-continue', вы должны установить таймаут
  и установить обработчик события `continue`.
  См. [RFC2616 Section 8.2.3](http://tools.ietf.org/html/rfc2616#section-8.2.3)
  для дополнительной информации.


### Событие: 'upgrade'

`function (request, socket, head)`

Генерируется каждый раз когда сервер отвечает на запрос предложением улучшить
соединение до безопасного. Если это событие не обрабатывается, клиент
при получении заголовка `upgrade` будет закрывать соединение.

См. описание события `upgrade` для `http.Server`.

### Событие: 'continue'

`function ()`

Наступает если сервер отправляет ответ с кодом '100 Continue', обычно в случае
если зщапрос включает заголовк 'Expect: 100-continue'. Это является указанием
клиенту на необходимость начала отправки тела запроса.


### http.createClient(port, host='localhost', secure=false, [credentials])

Создаёт новый HTTP клиент. `port` и `host` относятся к серверу, к которому
производится подключение. Поток не создаётся до отправки запроса.

`secure` — дополнительный двоичный флаг для включения поддержки HTTPS,
а `credentials` — необязательный объект параметров для crypto-модуля,
хранящий private-ключ клиента, сертификат и список доверенных CA сертификатов.

Если соединение зашифровано, но в объекте параметров не переданы сертификаты CA,
Node будет использовать публично доступный список CA, который представлен в
<http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt>.

### client.request(method='GET', path, [request_headers])

Отправляет запрос; при необходимости инициирует соединение.
Возвращает экземпляр `http.ClientRequest`.

`method` — необязательный параметр, по умолчанию принимает значение 'GET'.

`request_headers` необязательный параметр. Дополнительные заголовки запроса
могут быть добавлены внутри Node. Возвращает объект `http.ClientRequest`.

Не забудьте включить заголовок `Content-Length` если планируете отправить тело
запроса. Если вы хотите отправить тело запроса потоком, поставьте
`Transfer-Encoding: chunked`.

*ВНИМАНИЕ:* запрос ещё не закончен. Этот метод только отсылает заголовки серверу.
Необходимо вызвать `request.end()` чтобы отправить запрос целиком и получить ответ.
(Это звучит сложно, но позволяет пользователю передавать тело запроса
в потоковом режиме с помощью `request.write()`.)

### client.verifyPeer()

Возвращает true или false в зависимости от подлинности сертификата сервера
соответственно списку доверенных сертификатов CA (переданному явно или используемому по умолчанию).

### client.getPeerCertificate()

Возвращает JSON с деталями сертификата сервера, содержит поля `'subject'`, `'issuer'`, `'valid_from'` и `'valid_to'`.


## http.ClientRequest

Объект создаётся внутри Node и возвращается методом `request()` объекта `http.Client`.
Он представляет собой _незаконченный запрос_, заголовки которого уже отправлены.

Чтобы получить ответ, добавьте обработчик событию `'response'` объекта запроса.
Событие `'response'` будет сгенерировано объектом запроса при получении
заголовков ответа. Обработчик события `'response'` выполняется с одним
аргументом — экземпляром `http.ClientResponse`.

Во время события `'response'` можно добавлять обработчики к объекту ответа;
в частности, чтобы получать части тела ответа надо добавить обработчик
событию `'data'`. Заметьте что обработчик события `'response'` вызывается
до того, как будут получены части тела ответа, поэтому не надо беспокоиться,
что первая часть тела будет пропущена. Если обработчик `'data'` добавляется
во время события `'response'`, то всё тело ответа будет получено наверняка.


    // Good
    request.on('response', function (response) {
      response.on('data', function (chunk) {
        console.log('BODY: ' + chunk);
      });
    });

    // Bad - misses all or part of the body
    request.on('response', function (response) {
      setTimeout(function () {
        response.on('data', function (chunk) {
          console.log('BODY: ' + chunk);
        });
      }, 10);
    });

Это `поток с возможностью записи`.

Это экземпляр `EventEmitter` со следующими событиями:

### Событие: 'response'

`function (response) { }`

Генерируется когда на запрос приходит ответ. Это событие генерируется только
один раз. Аргументом обработчика `response` будет экземпляр `http.ClientResponse`.


### request.write(chunk, encoding='utf8')

Отправляет часть тела запроса. Вызывая этот метод несколько раз, пользователь
может отправлять тело ответа серверу в потоковом режиме — в таком случае
предпочтительно добавлять в заголовки `['Transfer-Encoding', 'chunked']`
при создании запроса.

Аргумент `chunk` должен быть массивом чисел или строкой.

Аргумент `encoding` необязателен и имеет значение только если `chunk` строка.

### request.end([data], [encoding])

Завершает отправку запроса. Если какие то части тела запроса ещё не были
отправлены, они отправляются. Если запрос разбит на части, будет послана
завершающая последовательность `'0\r\n\r\n'`.

Если задан аргумент `data`, то этот вызов эквивалентен поледовательному вызову
`request.write(data, encoding)` и `request.end()`.

## http.ClientResponse

Этот объект создаётся при создании запроса с помощью `http.Client`.
Он передаётся обработчику события `'response'` объекта запроса.

Объект ответа — `поток с возможностью чтения`.

### Событие: 'data'

`function (chunk) {}`

Часть тела сообщения передаётся обработчику в качестве единственного аргуметна.
Строка уже преобразована из кодировки с помощью которой осуществлялась передача.
Часть тела сообщения передаётся обработчику в виде строки. Кодировка тела
сообщения задаётся `response.setBodyEncoding()`.

### Событие: 'end'

`function () {}`

Генерируется только однажды для каждого сообщения. Обработчик вызывается
без аргументов. После этого сообщение не будет генерировать никаких событий.

### response.statusCode

Код статуса HTTP из трёх цифр, например `404`.

### response.httpVersion

Версия HTTP для текущего соединения. Скорее всего либо `'1.1'`, либо `'1.0'`.
Также `response.httpVersionMajor` — первая цифра версии,
а `response.httpVersionMinor` — вторая.


### response.headers

Заголовки ответа.

### response.trailers

См. описание выше.

### response.setEncoding(encoding=null)

Задаёт кодировку тела ответа. Может принимать значения `'utf8'`, `'ascii'`
или `'base64'`. По умолчанию используется `null`, что означает что в обработчик
события `'data'` поступает буфер.

### response.pause()

Приостанавливает генерацию событий ответом.
Можно использовать для ускорения закачки файла.

### response.resume()

Возобновляет генерацию событий ответом.

### response.client

Ссылка на `http.Client` которому принадлежит ответ.

