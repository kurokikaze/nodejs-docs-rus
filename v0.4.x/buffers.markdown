## Буферы

Чистый JavaScript поддерживает Unicode, но в нём нет средств для работы
с двоичными данными. При работе с TCP или файловой системой часто необходимо
работать именно с потоками двоичных данных. В Node предусмотрено несколько
средств управления, создания и приёма двоичных потоков.

Бинарные данные хранятся в экземплярах класса Buffer. Buffer похож на массив
целых чисел, но ему соответствует область памяти, выделенная вне стандартной
кучи V8. Размер Buffer невозможно изменить после создания. 

Объект `Buffer` существует в глобальном пространстве имён.

При преобразовании между буферами и строками JavaScript требуется явно
указывать метод кодирования символов. Node поддерживает 3 кодировки для строк:

* `'ascii'` — только для 7-битных ASCII-строк. Этот метод кодирования очень
  быстрый, и будет сбрасывать старший бит символа, если тот установлен.

* `'utf8'` — Многобайтовые Unicode-символы. Многие веб-страницы и документы используют UTF-8.

+ `'ucs2'` — Двухбайтовые little endian Unicode-символы.
  Могут кодировать только символы в диапазоне U+0000 - U+FFFF (Basic Multilingual Plane).

* `'binary'` — устаревший способ. Хранит двоичные данные в строке используя
  младшие 8 бит каждого символа. Не используйте эту кодировку.


### new Buffer(size)

Создаёт новый буфер размера `size` байт.

### new Buffer(array)

Создаёт новый буфер из массива `array` 8-битных символов.

### new Buffer(str, encoding='utf8')

Создаёт новый буфер, содержащий строку `str` в кодировке `encoding`.

### buffer.write(string, offset=0, encoding='utf8')

Записывает строку `string` в буфер по смещению `offset` от его начала
с использованием указанной кодировки. Возвращает количество записанных байт.
Если `buffer` не имеет достаточно места для сохранения всей строки,
то метод запишет только её часть. Этот метод не будет записывать частичные символы.

Пример: записать UTF-8 строку в буфер, потом напечатать его.

    buf = new Buffer(256);
    len = buf.write('\u00bd + \u00bc = \u00be', 0);
    console.log(len + " bytes: " + buf.toString('utf8', 0, len));

Количество записанных символов (которое может отличаться от количества записанных байт)
устанавливается в `Buffer._charsWritten`
и может быть изменено при следующем вызове `buf.write()`.

### buffer.toString(encoding, start=0, end=buffer.length)

Декодирует и возвращает строку из данных буфера, закодированных в кодировке
`encoding` начиная с позиции `start` и заканчивая позицией `end`.

См. пример `buffer.write()` выше.


### buffer[index]

Получает или устанавливает байт на позиции `index`. Значения соответствуют индивидуальным
байтам и могут лежать в пределах от `0x00` до `0xFF` в шестнадцатиричной записи
и от `0` до `255` в десятичной. 

Пример: скопировать ASCII строку в буфер, байт за байтом.

    str = "node.js";
    buf = new Buffer(str.length);

    for (var i = 0; i < str.length ; i++) {
      buf[i] = str.charCodeAt(i);
    }

    console.log(buf);

    // node.js


### Buffer.isBuffer(obj)

Проверяет, является ли `obj` буфером.


### Buffer.byteLength(string, encoding='utf8')

Возвращает количество байт в строке. Это не то же самое что `String.prototype.length`,
так как этот метод возвращает число *символов* в строке.

Пример:

    str = '\u00bd + \u00bc = \u00be';

    console.log(str + ": " + str.length + " characters, " +
      Buffer.byteLength(str, 'utf8') + " bytes");

    // ½ + ¼ = ¾: 9 characters, 12 bytes


### buffer.length

Размер буфера в байтах. Заметьте, что это значение не всегда соответствует размеру
содержимого. `length` возвращает объем памяти, зарезервированный для объекта буфера.
Это значение не изменяется при изменении содержимого буфера.

    buf = new Buffer(1234);

    console.log(buf.length);
    buf.write("some string", "ascii", 0);
    console.log(buf.length);

    // 1234
    // 1234

### buffer.copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)

Копирует данные между буферами с помощью memcpy().

Пример: создадим два буфера, потом скопировать `buf1`
с байта 16 по байт 19 в `buf2`, начиная с 8-го байта в `buf2`.

    buf1 = new Buffer(26);
    buf2 = new Buffer(26);

    for (var i = 0 ; i < 26 ; i++) {
      buf1[i] = i + 97; // 97 is ASCII a
      buf2[i] = 33; // ASCII !
    }

    buf1.copy(buf2, 8, 16, 20);
    console.log(buf2.toString('ascii', 0, 25));

    // !!!!!!!!qrst!!!!!!!!!!!!!

### buffer.slice(start, end=buffer.length)

Возвращает новый буфер, указывающий на ту же область памяти что предыдущий,
но начиная со `start` и заканчивая `end` байтами.

**Изменение содержимого нового буфера затронет содержимое старого!**

Пример: построить буфер с ASCII-алфавитом, вырезать часть в новый буфер, затем
изменить 1 часть в оригинальном буфере.

    var buf1 = new Buffer(26);

    for (var i = 0 ; i < 26 ; i++) {
      buf1[i] = i + 97; // 97 is ASCII a
    }

    var buf2 = buf1.slice(0, 3);
    console.log(buf2.toString('ascii', 0, buf2.length));
    buf1[0] = 33;
    console.log(buf2.toString('ascii', 0, buf2.length));

    // abc
    // !bc

