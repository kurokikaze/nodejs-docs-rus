## TLS (SSL)

Используйте `require('tls')` чтобы получить доступ к функциям этого модуля.

Модуль `tls` использует OpenSSL чтобы предоставить Transport Layer Security и/или
Secure Socket Layer (SSL): зашифрованные соединения.

TLS/SSL это инфраструктура с публичными ключами. Каждый клиент и каждый сервер должны иметь собственный приватный ключ. Приватный ключ создаётся таким образом:

    openssl genrsa -out ryans-key.pem 1024

Все серверы и некоторые клиенты должны иметь сертификат. Сертификаты это публичные ключи подписанные Центром Сертификации или самим создателем сертификата. Первый шаг в получени сертификата: создание файла запроса на подпись сертификата (CSR, Certificate Signing Request). Это делается следующим образом:

    openssl req -new -key ryans-key.pem -out ryans-csr.pem

Чтобы создать самостоятельно подписанный сертификат CSR, сделайте:

    openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem

Либо Вы можете отправить CSR в Центр Сертификации для подписи.

(TODO: docs on creating a CA, for now interested users should just look at
`test/fixtures/keys/Makefile` in the Node source code)


### s = tls.connect(port, [host], [options], callback)

Создаёт новое соединение на выбранный порт и хост (хост по умолчанию - `localhost`). Опции `options` должны быть объектом, содержащим

  - `key`: Строка или буфер содержащие приватный ключ сервера в формате PEM (обязательно)

  - `cert`: Строка или буфер содержащие ключ сертификата сервера в формате PEM.

  - `ca`: Массив строк или буферов с доверенными сертификатами. Если этот массив пропущен, будут использованы "корневые" Центры Сертификации, например VeriSign. Они будут использованы для авторизации соединения.

`tls.connect()` возвращает текстовый объект `CryptoStream`.

После рукопожатия TLS/SSL вызывается переданная функция. Вызов произойдёт независимо от того был ли авторизрван сертификат. Пользователь сам должен проверить значение `s.authorized` чтобы увидеть был ли сертификат подписан одним из указанных центров. Если `s.authorized === false` то в переменной `s.authorizationError` будет содержаться объект соответствующей ошибки.

### STARTTLS

В ветке v0.4 нет функций для начала TLS-сессии для существующего TCP-соединения.
Тем не менее это возможно сделать. техника состоит в вызове `tls.createSecurePair()`,
который возвратит два потока: шифрованный и текстовый. Далее вам необходимо
перенаправить шифрованный поток в сокет, а в приложении использовать текстовый.

[Пример использование этой техники](http://gist.github.com/848444).


### tls.Server

Этот класс - подкласс `net.Server` и имеет те же методы. Вместо приёма простых TCP соединений он принимает защищённые соединения с использованием TLS или SSL.

Простой пример эхо-сервера (возвращает полученные данные):

    var tls = require('tls');
    var fs = require('fs');

    var options = {
      key: fs.readFileSync('server-key.pem'),
      cert: fs.readFileSync('server-cert.pem')
    };

    tls.createServer(options, function (s) {
      s.write("welcome!\n");
      s.pipe(s);
    }).listen(8000);


Вы можете проверить сервер, присоединившись к нему с помощью `openssl s_client`:


    openssl s_client -connect 127.0.0.1:8000


#### tls.createServer(options, secureConnectionListener)

Это конструктор для класса `tls.Server`. Объект опций может содержать следующие значения:

  - `key`:  Строка или буфер содержащие приватный ключ сервера в формате PEM (обязательно)

  - `cert`: Строка или буфер содержащие ключ сертификата сервера в формате PEM.

  - `ca`: Массив строк или буферов с доверенными сертификатами. Если этот массив пропущен, будут использованы "корневые" Центры Сертификации, например VeriSign. Они будут использованы для авторизации соединения.

  - `requestCert`: Если принимает значение `true` сервер будет запрашивать у клиентов сертификаты и пытаться проверять их подлинность. По умолчанию принимает значение `false`.

  - `rejectUnauthorized`: Если равно `true` сервер будет сбрасывать соединения сертификаты которых не подтверждены списком доверенных Центров Сертификации. Эта опция действует только если `requestCert` равен `true`. Значение по умолчанию: `false`.


#### Событие: 'secureConnection'

`function (cleartextStream) {}`

Это событие генерируется при приёме нового соединения после успешного прохождения рукопожатия. Аргумент - экземпляр `stream.Stream` открытый на чтение и запись. Он имеет все методы и события обычного потока.

`cleartextStream.authorized` - двоичное значение, сообщающее что клиент был проверен одним из заданных для сервера доверенных Центров Сертификации. Если это свойство принимает значение `false`, в `cleartextStream.authorizationError` будет храниться ошибка авторизации. Стоит заметить что в зависимости от настроек TLS-сервера неавторизованные соединения могут приниматься либо сбрасываться.


#### server.listen(port, [host], [callback])

Начинает приём соединений на указанном порту и адресе. Если адрес не указан, сервер принимает соединения на любой адрес IPv4 (`INADDR_ANY`).

Эта функция асинхронна. Коллбек, переданный последним параметром, будет вызван когда сервер будет готов к приёму соединений.

См. `net.Server` для дальнейшей информации.


#### server.close()

Прекращает приём новых соединений сервером. Эта функция асинхронна, сервер окончательно закрывается когда генерируется событие `'close'`.


#### server.maxConnections

Задайте это свойство чтобы сбрасывать новые соединения как только количество одновременных соединений достигнет указанного значения.

#### server.connections

Число одновременных соединений с сервером.
