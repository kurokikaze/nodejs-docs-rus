## Модуль криптографии

Используйте `require('crypto')` чтобы получить доступ к функциям модуля.

Криптографический модуль требует для своей работы наличия OpenSSL.
Он предоставляет возможность использовать аутентификацию в HTTPS и HTTP-соединениях.

Модуль также предоставляет набор обёрток для некоторых методов OpenSSL:
hash, hmac, cipher, decipher, sign и verify.

### crypto.createCredentials(details)

Создаёт объект данных аутентификации, может принимать параметром объект со следующими свойствами:

* `key` : строка с PEM-закодированным приватным ключом,
* `cert` : строка с PEM-закодированным сертификатом,
* `ca` : строка или список строк PEM-закодированных доверенных корневых сертификатов.

Если корневые сертификаты не указаны, node.js будет использовать список доверенных сертификатов,
расположенный по адресу <http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt>.


### crypto.createHash(algorithm)

Создает и возвращает объект `hash`, который может быть использован
для создания криптографических хэшей по заданному алгоритму.

Возможные значения для `algorithm` зависят от доступных алгоритмах в той версии OpenSSL,
которая у вас установлена. Например, это может быть `'sha1'`, `'md5'` и т.д.
В последней версии OpenSSL список поддерживаемых алгоритмов можно было узнать
с помощью команды `openssl list-message-digest-algorithms`.

Пример: программа, рассчитывающая sha1 хеш-сумму содержимого файла.

    var filename = process.argv[2];
    var crypto = require('crypto');
    var fs = require('fs');

    var shasum = crypto.createHash('sha1');

    var s = fs.ReadStream(filename);
    s.on('data', function(d) {
      shasum.update(d);
    });

    s.on('end', function() {
      var d = shasum.digest('hex');
      console.log(d + '  ' + filename);
    });

### hash.update(data)

Обновляет содержимое на `data`. Этот метод может быть вызван несколько раз.

### hash.digest(encoding='binary')

Вычисляет хеш от всех поступивших данных.
Параметр `encoding` может равняться `'hex'`, `'binary'` или `'base64'`.

Замечание: объект `hash` нельзя использовать после того, как будет вызван метод `digest()`.


### crypto.createHmac(algorithm, key)

Создает и возвращает объект `hmac`, который может быть использован
для создания хеш-кода идентификации сообщений (HMAC) по заданному алгоритму и ключу.

Возможные значения для `algorithm` зависят от доступных алгоритмах в OpenSSL,
см. описание для `crypto.createHash()` выше. `key` определяет используемый ключ.

### hmac.update(data)

Обновляет содержимое на `data`. Этот метод может быть вызван несколько раз.

### hmac.digest(encoding='binary')

Вычисляет хеш от всех поступивших данных.
Параметр encoding может равняться `'hex'`, `'binary'` или `'base64'`.

Замечание: объект `hmac` нельзя использовать после того, как будет вызван метод `digest()`.


### crypto.createCipher(algorithm, password)

Создает и возвращает объект `cipher`, который может быть использован
для шифрования по заданному алгоритму и паролю.

Возможные значения для `algorithm` зависят от доступных алгоритмах в той версии OpenSSL,
которая у вас установлена. Например, это может быть `'aes192'`, `'blowfish'` и т.д.
В последней версии OpenSSL список поддерживаемых алгоритмов можно было узнать
с помощью команды `openssl list-cipher-algorithms`.

`password` используется для получения информации о ключе и IV, и должен быть строкой,
закодированной с использованием кодировки `'binary'` (см. [Buffers](buffers.html)).

### crypto.createCipheriv(algorithm, key, iv)

Создает и возвращает объект `cipher`, который может быть использован
для шифрования по заданному алгоритму, ключу и IV.

`algorithm` может иметь такие же значения, что и для метода `createCipher()`. `key` является ключём,
используемым в этом алгоритме. `iv` задаёт вектор инициализации. `key` и `iv` должны быть строками,
закодированными с использованием кодировки `'binary'` (см. [Buffers](buffers.html)).

### cipher.update(data, input_encoding='binary', output_encoding='binary')

Обновляет содержимое на `data`, кодировку которых задаёт аргумент `input_encoding`
(может равняться `'utf8'`, `'ascii'` или `'binary'`). Аргумент `output_encoding`
определяет выходной формат и может равняться `'binary'`, `'base64'` или `'hex'`.

Возвращает зашифрованного содержимого и может быть названо много раз с новыми данными.

### cipher.final(output_encoding='binary')

Возвращает все оставшиеся зашифрованного содержимого в кодировке `output_encoding`,
которая может равняться `'binary'`, `'ascii'` или `'utf8'`.

Замечание: объект `cipher` не может быть использован после вызова метода `final()`.


### crypto.createDecipher(algorithm, password)

Создает и возвращает объект `decipher`, который может быть использован
для дешифрования по заданному алгоритму и паролю.
Это метод-близнец для [createCipher()](#crypto.createCipher)`, описанному выше.

### crypto.createDecipheriv(algorithm, key, iv)

Создает и возвращает объект `decipher`, который может быть использован
для дешифрования по заданному алгоритму, ключу и IV.
Это метод-близнец для [createCipheriv()](#crypto.createCipheriv), описанному выше.

### decipher.update(data, input_encoding='binary', output_encoding='binary')

Обновляет содержимое на `data`, формат которых задаёт аргумент `input_encoding`
(может равняться `'binary'`, `'base64'` или `'hex'`). Аргумент `output_encoding`
определяет выходную кодировку и может равняться `'utf8'`, `'ascii'` или `'binary'`.

### decipher.final(output_encoding='binary')

Возвращает все оставшиеся разшифрованного содержимого в виде простого текста.
Значение аргументо output_encoding объяснено выше.

Замечание: объект `decipher` не может быть использован после вызова метода `final()`.


### crypto.createSign(algorithm)

Создает и возвращает объект `signer`, который может быть использован
для создания электронной подписи по заданному алгоритму.

### signer.update(data)

Обновляет содержимое на `data`. Этот метод может быть вызван несколько раз.

### signer.sign(private_key, output_format='binary')

Вычисляет подпись для всех данных. `private_key` задаёт закрытый ключ в формате PEM.

Возвращает подпись в формате `output_format`, который может равняться `'binary'`, `'hex'` или `'base64'`.

Замечание: объект `signer` не может быть использован после вызова метода `sign()`.


### crypto.createVerify(algorithm)

Создает и возвращает объект `verifier`, который может быть использован
для проверки электронной подписи. Это объект-близнец для объекта `signer`.

### verifier.update(data)

Обновляет содержимое на `data`. Этот метод может быть вызван несколько раз.

### verifier.verify(cert, signature, signature_format='binary')

Проверяет данные с помощью сертификата `cert` в формате PEM и подписи
`signature` формата `signature_format` (может равняться `'binary'`, `'hex'` или `'base64'`.

Возвращает `true` или `false` в зависимости от действительности подписи и публичного ключа.

Замечание: объект `verifier` не может быть использован после вызова метода `verify()`.

